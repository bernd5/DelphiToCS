using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace delphi2cs
{
    class DelphiConverter
    {
        public string pasText { get; set; }
        public string csText { get; set; }
        private DelphiTokenizer tokens = new DelphiTokenizer();
        private int Ident = 0;
        private bool BlockAreadyOpen = false;
        public delegate void ProgressHandler(int precent);
        public event ProgressHandler OnProgress;

        //----------------------------------------------------------------------
        internal void Convert()
        {
            try
            {
                output("//");
                output("// code generated by Delphi2CS");
                output("//");
                tokens.LoadString(pasText);
//                output("namespace DelphiToCS");
                ParseGeneralStatment();
            }
            catch (Exception x)
            {
                csText += x.Message;
            }
        }

        //----------------------------------------------------------------------
        internal void outputLine()
        {
            string message = "//".PadLeft(4 * Ident).PadRight(80, '-');
            outputRaw(message);
        }

        //----------------------------------------------------------------------
        internal void outputNoIdent(string message)
        {           
            outputRaw(message);
        }


        
        //----------------------------------------------------------------------
        internal void output(string Format, params Object[] args)
        {
            string message = string.Format(Format, args);
            if (Ident <= 0)
                Ident = 0;
            else
                message = " ".PadLeft(4 * Ident) + message;
            outputRaw(message);
        }

        //----------------------------------------------------------------------
        private void outputRaw(string message)
        {
            csText += message + "\r\n";
            System.Diagnostics.Debug.WriteLine(message);
        }

        //----------------------------------------------------------------------
        private void ParseGeneralStatment()
        {
            if (OnProgress != null)
                OnProgress(tokens.Percent());
      
            while (true)
            {
                string token = tokens.NextToken().ToLower();
                string name = "";

                switch (token)
                {
                    case "":
                        return; // EOF
                        break;

                    case "unit":
                    case "program":
                        name = tokens.NextToken();
                        tokens.Expect(";");
                        break;
                    case "interface":
                    case "implementation":
                        break;
                    case "uses":
                        while (tokens.PeekToken() != ";")
                        {
                            name = tokens.NextToken();
                            output("using {0};", name);
                            if (tokens.PeekToken() == ",")
                                tokens.NextToken();
                        }
                        tokens.Expect(";");
                        break;
                    case "const":
                        ParseConstants();
                        break;
                    case "type":
                        ParseTypes();
                        break;
                    case "var":
                    case "threadvar":
                        ParseVarsBlock();
                        //BlockAreadyOpen = true;
                        break;
                    case "label":
                        ParseLabels();
                        break;
                    case "function":
                    case "procedure":
                    case "constructor":
                    case "destructor":
                        output("");
                        outputLine();
                        output(ParseFunctionHeader(""));
                        tokens.Expect(";");
                        BlockOpen();
                        BlockAreadyOpen = true;
                        ParseGeneralStatment();
                        break;
                    case "begin":
                        ParseCodeBlock();
                        return;
                        break;
//                    case "end":
//                        tokens.Expect(".");
//                        break;
                    default:
                        throw new Exception("unknown key word '"+token+"'");
                        break;
                }
                output("");
            }
        }

        //-------------------------------------------------------------------------
        private void ParseCodeBlock()
        {
            ParseCodeBlock("end");
        }

        //-------------------------------------------------------------------------
        private void ParseCodeBlock(string endString)
        {
            BlockOpen();

            bool workaround = false;
            string token = tokens.NextToken().ToLower();
            string feedback = "";

            while (token != endString)
            {
                feedback = ParseCodeLine(token);
                if ((feedback == ";") || (feedback == ""))
                    token = tokens.NextToken();
                else
                {
                    token = feedback;
                    workaround = true;
                }                                    
            }

            if ((endString=="end") && (tokens.PeekToken().ToLower() != "else"))
              tokens.Expect(";");

            BlockClose(); 
        }

        //-------------------------------------------------------------------------
        private void BlockOpen()
        {
            if (BlockAreadyOpen)
                BlockAreadyOpen = false;
            else
            {
                output("{{");
                Ident++;
            }
        }

        //-------------------------------------------------------------------------
        private void BlockClose()
        {
            BlockClose("");
        }

        //-------------------------------------------------------------------------
        private void BlockClose(string remark)
        {
            if (remark != "")
                remark = " // " + remark;
            Ident--;
            output("}}"+remark);
        }


        //-------------------------------------------------------------------------
        private string ParseCodeLine(string token)
        {
            string feedback = "";
            switch (token.ToLower())
            {
                case "begin":
                    ParseCodeBlock();
                    break;
                case "while":
                    string cond = tokens.ReadUntil("do");
                    output("while ({0})", cond);
                    ParseCodeLine(tokens.NextToken());
                    break;
                case "repeat":
                    output("do");
                    BlockOpen();
                    ParseCodeBlock("until");
                    string repeat_cond = tokens.ReadUntil(";");
                    output("while ({0});", repeat_cond);
                    break;
                case "with":
                    string cond2 = tokens.ReadUntil("do");
                    output("with ({0})", cond2);
                    ParseCodeLine(tokens.NextToken());
                    break;
                case "for":
                    string for_var = tokens.NextToken();
                    tokens.Expect(":=");
                    string found;
                    string for_val1 = tokens.ReadUntil(new string[] {"to", "downto"}, out found);
                    //if (tokens.PeekToken() == "downto")
                    //    tokens.Expect("downto");
                    //else
                    //    tokens.Expect("to");
                    string for_val2 = tokens.ReadUntil("do");
                    //tokens.Expect("do");
                    output("for ({0} = {1} ; {0} <= {2} ; {0}++)", for_var, for_val1, for_val2);
                    ParseCodeLine(tokens.NextToken());
                    break;
                case "if":
                    bool if_ident = false;
                    string cond1 = BeutifyCondition(tokens.ReadUntil("then"));
                    output("if ({0})", cond1);
                    if (tokens.PeekToken() != "begin")
                    {
                        Ident++;
                        if_ident = true;
                    }
                    string iffeedback = ParseCodeLine(tokens.NextToken());
                    if (if_ident)
                    {
                        Ident--;
                        if_ident = false;
                    }
                    if ((iffeedback == "else") || (tokens.PeekToken().ToLower() == "else"))
                    {
                        if (iffeedback != "else")
                          tokens.Expect("else");
                        output("else");
                        if (tokens.PeekToken() != "begin")
                        {
                            Ident++;
                            if_ident = true;
                        }
                        ParseCodeLine(tokens.NextToken());
                        if (if_ident)
                        {
                            Ident--;
                            if_ident = false;
                        }
                    }
                    break;
                case "case":
                    string case_var = tokens.ReadUntil("of");
                    output("switch({0})", case_var);
                    BlockOpen();
                    while (tokens.PeekToken() != "end")
                    {
                        string case_val = tokens.NextToken();
                        if (case_val != "else")
                        {
                            tokens.Expect(":");
                            output("case {0}:", case_val);
                        }
                        else
                        {
                            output("default:");
                        }
                        ParseCodeLine(tokens.NextToken());
                        output("break;");

                    }
                    tokens.Expect("end");
                    tokens.Expect(";");
                    BlockClose();
                    break;
                case "asm":
                    string asm;
                    while (tokens.PeekToken() != "end")
                        asm = tokens.NextToken();
                    tokens.Expect("end");
                    tokens.Expect(";");
                    output(" /* asm section removed */ ");
                    break;
                case "try":
                    output("try");
                    BlockOpen();
                    break;
                case "except":
                    BlockClose();
                    if (tokens.PeekToken().ToLower() == "on")
                    {
                        tokens.Expect("on");
                        string var = tokens.NextToken();
                        string type = "";
                        if (tokens.PeekToken() == ":")
                        {
                            tokens.Expect(":");
                            type = tokens.NextToken();
                        }
                        else
                        {
                            type = var;
                            var = "";
                        }
                        tokens.Expect("do");
                        output("catch ({0} {1})",type,var);
                        ParseCodeLine(tokens.NextToken());
                    }
                    while (tokens.PeekToken().ToLower() != "end")
                        ParseCodeLine(tokens.NextToken());
                    
                    tokens.Expect("end");
                    tokens.Expect(";");
                    break;

                case "finally":
                    BlockClose();
                    output("finally()");
                    ParseCodeBlock();
                    break;
                case "raise":
                    string ex_name = tokens.NextToken();
                    tokens.Expect(".");
                    tokens.Expect("create");
                    tokens.Expect("(");
                    string ex_msg = tokens.ReadUntil(")");
                    output("throw new {0}(\"{1}\");", ex_name, ex_msg);
                    tokens.Expect(";");
                    break;
                case "goto":
                    string goto_label = tokens.NextToken();
                    output("goto {0};", goto_label);
                    if (tokens.PeekToken() != "else")
                        tokens.Expect(";");
                    break;
                case "inherited":
                    string inh_func = tokens.NextToken();
                    if (tokens.PeekToken() == "(") // function with params
                        inh_func += ParseNestedParams("(", ")");
                    output("base:{0};",inh_func);
                    tokens.Expect(";");
                    break;
                default:
                    // check for Label:
                    if (tokens.PeekToken() == ":") // label
                    {
                        outputNoIdent(token + ":");
                        tokens.Expect(":");
                        break;
                    }

                    // either a label, a := or a function call
                    // termination are ';' ':=' 'end' 'else' 
                    string rv = token;
                    bool rv_handled = false;
                    string peek = tokens.PeekToken();
                    while ((peek != ";") && (peek !=":=") && (peek != "end") && (peek != "else"))
                    {
                        if (tokens.PeekToken() == ".") // object member
                        {
                            tokens.Expect(".");
                            rv = rv + "." + tokens.NextToken();
                        }

                        else if (tokens.PeekToken() == "(") // handle function with params
                        {
                            rv += ParseNestedParams("(",")");
                            rv_handled = true;
                        }                    

                        else if (tokens.PeekToken() == "^") // pointer
                        {
                            tokens.Expect("^");
                        }

                        else if (tokens.PeekToken() == "[") // array member
                        {
                            rv += ParseNestedParams("[", "]");
                        }
                        peek = tokens.PeekToken();      
                    }

                    if (tokens.PeekToken() == ":=")
                    {
                        tokens.Expect(":=");                        
                        string value = tokens.ReadUntil(new string[]{";", "end", "else"}, out feedback);
                        //if (value.EndsWith(" end")) // special case : no ; in last statment before end;
                        value = value.Replace("\n", "");
                        value = value.Replace("{", "/*");
                        value = value.Replace("}", "*/");
                        rv += String.Format(" = {0}", value);
                        rv_handled = true;
                    }
                    else
                       if ((tokens.PeekToken() != "else") && (tokens.PeekToken() != "end"))
                           tokens.Expect(";");

                        // function call without params ??
                        if (!rv_handled)
                            rv += "()";
                        output(rv + ";");
                        break;
                    
            }
            return feedback;
        }

        
        //----------------------------------------------------------------------
        private string ParseNestedParams(string open, string close)
        {
            tokens.Expect(open);
            string prms = open;
            int count = 1;
            while (count > 0)
            {
                string tmp1 = tokens.NextToken();
                if (tmp1 == ",")
                    prms += ", ";
                else
                    prms += tmp1;
                if (tmp1 == open)
                    count++;
                else if (tmp1 == close)
                    count--;
            }
            return prms;
            
        }
        //----------------------------------------------------------------------
        private string ParseVariableExpression()
        {
            string peek = tokens.PeekToken();
            string rv = "";
            while ((peek == ".") || (peek == "(") || (peek == "[") || (peek == "^"))
            {
                if (tokens.PeekToken() == ".") // object member
                {
                    tokens.Expect(".");
                    rv = rv + "." + tokens.NextToken();
                }

                else if (tokens.PeekToken() == "(") // handle function with params
                {
                    rv += ParseNestedParams("(", ")");                    
                }

                else if (tokens.PeekToken() == "^") // pointer
                {
                    tokens.Expect("^");
                }

                else if (tokens.PeekToken() == "[") // array member
                {
                    rv += ParseNestedParams("[", "]");
                }
                peek = tokens.PeekToken();
            }
            return rv;
        }

        //----------------------------------------------------------------------
        private bool isReservedWord(string token)
        {
            string[] words = { "var", "type", "const", "threadvar", "label", "implementation", "interface", "begin", "procedure", "function" };
                foreach (string word in words)
                    if (token == word)
                        return true;
            return false;

        }

        //----------------------------------------------------------------------
        private void ParseConstants()
        {            
            bool istoken = true;
            while (istoken)
            {
                string token = tokens.PeekToken().ToLower();
                if (isReservedWord(token))             
                    istoken = false;                   
                else if (token.StartsWith("//"))
                    tokens.NextToken();
                else if (token == "const")
                    tokens.NextToken();
                else if (token == "") //error
                    break;
                else
                {
                    string name = tokens.NextToken();
                    if (tokens.PeekToken() == ":")
                    {
                        name = ParseOneVariable("", name);
                    }

                    tokens.Expect("=");
                    string value = tokens.ReadUntil(";");
                    output("const {0} = {1};", name, value);

                } 
            
            }
        }

        //----------------------------------------------------------------------
        private void ParseLabels()
        {
            string token = tokens.NextToken().ToLower();
            while (tokens.PeekToken() == ",")
            {
                tokens.Expect(",");
                token = tokens.NextToken().ToLower();
            }

            tokens.Expect(";");

        }

        //----------------------------------------------------------------------
        private void ParseTypes()
        {
            bool istoken = true;
            while (istoken)
            {
                string token = tokens.PeekToken().ToLower();
                if (isReservedWord(token))
                    istoken = false;
                else if (token == "type")
                    istoken = true;
                else
                {
                    string name = tokens.NextToken();
                    tokens.Expect("=");
                    string value = "";
                    string peek = tokens.PeekToken().ToLower();
                    if ((peek == "record") || (peek == "class"))
                        ParseClass(name);
                    else
                    {
                        value = tokens.ReadUntil(";");
                        output("typedef {0} = {1};", name, value);
                    }
                }

            }
        }

        //----------------------------------------------------------------------
        private void ParseVarsBlock()
        {

            bool istoken = true;
            while (istoken)
            {
                string token = tokens.PeekToken().ToLower();
                if (isReservedWord(token))
                    istoken = false;
                else if (token == "var")
                    istoken = true;
                else
                {               
                    string rv = ParseOneVariable("", tokens.NextToken());
                    if (tokens.PeekToken() == "=")
                    {
                        tokens.Expect("=");                        
                        rv += " = " + tokens.ReadUntil(";");
                    }
                    else
                      tokens.Expect(";");
                    output(rv + ";");
                }

            }
        }
        
        //----------------------------------------------------------------------
        private void ParseClass(string className)
        {
            string prefix = "";
            string inherits = "";
            string name = "";
            string def = tokens.NextToken(); // "class" or "record"

            if (tokens.PeekToken() == "(")
            {
                tokens.Expect("(");
                inherits = tokens.NextToken();
                tokens.Expect(")");
            }
            if (inherits == "")
                output("class {0}", className);
            else
                output("class {0} : {1}", className, inherits);
            BlockOpen();

            string next = "";
            while (next != "end")
            {
                name = "";
                next = tokens.NextToken().ToLower();

                string type = "";
                switch (next)
                {
                    case "end":
                        
                        break;
                    case "private":
                    case "public":
                        prefix = next + " ";
                        break;
                    case "override":
                        tokens.Expect(";");
                        output("//line above is an 'override'");
                        break;
                    case "message":
                        output("// line above is windows message '{0}'",tokens.ReadUntil(";"));
                        break;
                    case "procedure":
                    case "constructor":
                    case "destructor":
                    case "function":
                        string rv = ParseFunctionHeader(prefix) + ";";
                        output(rv);
                        tokens.Expect(";");
                        break;
                    case "property":
                        //property StopEvent :THandle read FStopEvent write FStopEvent;
                        name = tokens.NextToken();
                        tokens.Expect(":");
                        type = tokens.NextToken();
                        tokens.Expect("read");
                        string rd = tokens.NextToken();
                        tokens.Expect("write");
                        string wr = tokens.NextToken();
                        tokens.Expect(";");
                        output("{2}{0} {1} {{ get {{return {3};}} set {{{4} = value;}} }}",type, name, prefix, rd, wr);
                        break;
                    default:
                        output(ParseOneVariable(prefix, next)+";");
                        tokens.Expect(";");
                        break;
                }
            }
            tokens.Expect(";");
            BlockClose(String.Format(" of class {0}",className));
            output("");
        }

        //----------------------------------------------------------------------
        private string ParseFunctionHeader(string prefix)
        {            
            string rc = "void";
            string prms = "";
            string name = tokens.NextToken();
            if (name == "GetListOfFilesAndFolders")
                Console.WriteLine();
            while (tokens.PeekToken() == ".")
            {
                tokens.Expect(".");
                name = name + "." + tokens.NextToken();
            }

            if (tokens.PeekToken() == "(")
            {
                tokens.Expect("(");
                while (tokens.PeekToken() != ")")
                {
                    if (tokens.PeekToken().ToLower() == "var")
                    {
                        tokens.Expect("var");
                        prms += "ref ";
                    }
                    if (tokens.PeekToken().ToLower() == "out")
                    {
                        tokens.Expect("out");
                        prms += "out ";
                    } 
                    if (tokens.PeekToken().ToLower() == "const")
                        tokens.NextToken();
                    prms += ParseOneVariable("", tokens.NextToken());

                    if (tokens.PeekToken() == ";")
                    {
                        prms += ", ";
                        tokens.NextToken();
                    }
                }
                tokens.Expect(")");

            }
            if (tokens.PeekToken() == ":")
            {
                tokens.Expect(":");
                rc = tokens.NextToken();
            }

            string rv = string.Format("{0}{1} {2}({3})", prefix, ConvertVarType(rc), name, prms);
            return rv;
        }
        //----------------------------------------------------------------------

        private string ParseOneVariable(string prefix, string name)
        {
            int ArrayDim = 0;
            string type = "";
            int[] ArraySize = new int[10];
            
            while (tokens.PeekToken() == ",")
            {
                tokens.Expect(",");
                name += ", " + tokens.NextToken();
            }
            tokens.Expect(":");
            type = tokens.NextToken();
            
            if (type == "^")
                type += tokens.NextToken();
            while (type == "array")
            {
                if (tokens.PeekToken() == "[")
                {
                    tokens.Expect("[");
                    int from = int.Parse(tokens.NextToken());
                    tokens.Expect("..");
                    int upto = int.Parse(tokens.NextToken());
                    ArraySize[ArrayDim++] = upto - from + 1;
                    tokens.Expect("]");
                }
                else
                {
                    ArrayDim = -1;
                }
                tokens.Expect("of");
                type = tokens.NextToken();
            }
            if (type.ToLower() == "string")
            {
                if (tokens.PeekToken() == "[")
                {
                    tokens.Expect("[");
                    string remarks = tokens.NextToken();
                    tokens.Expect("]");
                }
            }


            type = ConvertVarType(type);

            if (ArrayDim == 0) // not an array
                return String.Format("{2}{0} {1}", type, name, prefix);
            else if (ArrayDim < 0) // array dimenstions were not specified
            {
                return String.Format("{2}{0}[] {1}", type, name, prefix);
            }
            else // array
            {
                string deg = "".PadLeft(ArrayDim - 1, ',');
                string dims = "";
                for (int i = 0; i < ArrayDim; i++)
                    dims += ArraySize[i].ToString() + ", ";
                dims = dims.Remove(dims.Length - 2);
                return String.Format("{2}{0}[{3}] {1} = new {0}[{4}]", type, name, prefix, deg, dims);
            }
        }
        //----------------------------------------------------------------------
        private string ConvertVarType(string type)
        {
            /*
             *    // Integer data types :                                                       C# equvalent
             *       Byte;     //                        0 to 255                               byte            U 8
             *       ShortInt; //                     -127 to 127                               sbyte           S 8
             *       Word;     //                        0 to 65,535                            ushort          U 16
             *       SmallInt; //                  -32,768 to 32,767                            short           S 16
             *       LongWord; //                        0 to 4,294,967,295                     uint            U 16
             *       Cardinal; //                        0 to 4,294,967,295                     uint            U 16
             *       LongInt;  //           -2,147,483,648 to 2,147,483,647                     int             S 32
             *       Integer;  //           -2,147,483,648 to 2,147,483,647                     int             S 32
             *       Int64;    // -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807       long            S 64
             *     
             * // Decimal data types :
             *      Single;   //  7  significant digits, exponent   -38 to +38                  float
             *      Currency; // 50+ significant digits, fixed 4 decimal places
             *      Double;   // 15  significant digits, exponent  -308 to +308                 double
             *      Extended; // 19  significant digits, exponent -4932 to +4932                
             *      
             * // text variables
             *      Char;        // Holds a single character, small alphabet
             *      WideChar;    // Holds a single character, International alphabet
             *      AnsiChar;    // Holds a single character, small alphabet
             *      ShortString; // Holds a string of up to 255 Char's
             *      String;      // Holds strings of Char's of any size desired
             *      AnsiString;  // Holds strings of AnsiChar's any size desired
             *      WideString;  // Holds strings of WideChar's of any size desired
             *      
             *      Boolean;     // Can be 'True' or 'False'                                    bool 
             *      
             *  // delphi 2007
             *  DWORD = LongWord;
             *  Largeint = Int64;
             *  
             *  SHORT = Smallint;
             * 
             * UINT = LongWord;
             * ULONG = Cardinal;
             * LONGLONG = Int64;
             * TLargeInteger = Int64;
             * ULONGLONG = UInt64;
             */
            string rv = type.ToLower();
            switch (rv)
            {
                case "boolean": rv = "bool"; break;
                case "integer": rv = "int"; break;
                case "word":    rv = "uint"; break;
                case "dword": rv = "uint"; break;
                case "shortstring": rv = "string"; break;
                default: break;
            }
            return rv;
        }
        //----------------------------------------------------------------------
        private string BeautifyCondition(string p)
        {
            p = p.Replace(" and ", " && ");
            p = p.Replace(" or ", " || ");
            p = p.Replace("xor", "^");
            p = p.Replace("=", "==");
            p = p.Replace("<>", "!=");
            p = p.Replace("shr", ">>");
            p = p.Replace("shl", "<<");
            p = p.Replace("not", "!");
            p = p.Replace("\n", "");
            p = p.Replace("boolean", "bool");
            p = p.Replace("integer", "int");
            p = p.Replace("word", "uint");
            p = p.Replace("dword", "uint");
            p = p.Replace("shortstring", "string");
            return p;
        }
        //----------------------------------------------------------------------     

        
        

    }
}
